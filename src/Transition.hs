{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}
module Transition where

import Prelude hiding (lookup)
import Expr
import Template
import Order
import qualified Data.Map.Strict as M
import Control.Monad
import Later
import Control.Monad.Trans.State
import Control.Monad.Trans.Maybe
import Data.List (find)

-- | A variant of 'modify' in which the new state is generated by a
-- monadic action.
modifyM :: (Monad m) => (s -> m s) -> StateT s m ()
modifyM f = StateT $ \ s -> do
    s' <- f s
    return ((), s')
{-# INLINE modifyM #-}

type E = M.Map Name Addr
type H = M.Map Addr (E,Expr)
type K = [Frame]
data Frame = Apply Addr | Update Addr | Select E [Alt]
  deriving Show

type S = (Expr, E, H, K)

data Trace a = Step !S (Later (Trace a)) | Ret !a
  deriving Functor

instance Applicative Trace where
  pure = Ret
  (<*>) = ap

instance Monad Trace where
  Ret a >>= k = k a
  Step s m >>= k = Step s ((>>= k) <$> m)

newtype TracingState m a
  = TS { unTS :: StateT S m a }
  deriving (Functor, Applicative, Monad)

liftTS :: (forall a. m a -> m a) -> TracingState m a -> TracingState m a
liftTS f (TS (StateT m)) = TS (StateT (\h -> f (m h)))

liftTSL :: Functor l => (forall a. l (m a) -> m a) -> l (TracingState m v) -> TracingState m v
liftTSL f lm = TS (StateT (\h ->  f (fmap (\(TS (StateT m)) -> m h) lm)))

instance MonadTrace m => MonadTrace (TracingState m) where
  type L (TracingState m) = L m
  lookup x m = do
    TS $ modifyM $ \(Var x,ρ,μ,κ) -> do
      let a = ρ M.! x
          (ρ',e') = μ M.! a
      pure (e',ρ',μ,Update a : κ)
    liftTSL (lookup x) m
  app1 m = do
    TS $ modifyM $ \(App e x,ρ,μ,κ) -> do
      let a = ρ M.! x
      pure (e,ρ,μ,Apply a : κ)
    liftTS app1 m
  app2 m = do
    TS $ modifyM $ \(Lam x e,ρ,μ,Apply a : κ) -> do
      pure (e,M.insert x a ρ,μ,κ)
    liftTS app2 m
  bind m = do
    TS $ modifyM $ \(Let x e1 e2,ρ,μ,κ) -> do
      let a = maybe 0 (\(k,_) -> k+1) (M.lookupMax μ)
          ρ' = M.insert x a ρ
      pure (e2,ρ',M.insert a (ρ',e1) μ,κ)
    liftTS bind m
  case1 m = do
    TS $ modifyM $ \(Case e alts,ρ,μ,κ) -> do
      pure (e,ρ,μ,Select ρ alts : κ)
    liftTS case1 m
  case2 m = do
    TS $ modifyM $ \(ConApp k xs,ρ,μ,Select ρ' alts : κ) -> do
      let Just (_,ys,rhs) = find (\(k',_,_) -> k' == k) alts
          as = map (ρ M.!) xs
          ρ'' = foldr (uncurry M.insert) ρ' (zip ys as)
      pure (rhs,ρ'',μ,κ)
    liftTS case2 m
  let_ = error "not in call-by-need"
  update m = do
    TS $ modifyM $ \(v,ρ,μ,Update a:κ) -> do
      when (not (isVal v)) $ error "not a value"
      pure (v,ρ,M.insert a (ρ,v) μ,κ)
    liftTS update m

inj :: Expr -> S
inj e = (e,M.empty,M.empty,[])

runTS :: TracingState m a -> S -> m (a, S)
runTS = runStateT . unTS

evalTransition :: forall m. MonadCoindTrace m => Expr -> m S
evalTransition e = snd <$> runTS (evalByNeed @(TracingState m) e) (inj e)
